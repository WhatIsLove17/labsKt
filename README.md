# Практические задания
## Задание 1.
Дан многострочный текст и ширина страницы в символах. Необходимо “реализовать” выполнить выравнивание по левому краю, правому - краю, центру или ширине.


Правила:
- если следующие слово полностью не вмещается в строку его надо перенести
- если слово длиннее чем размер строки, его нужно перенести по символам. Знак переноса  “-” можно не использовать
-	при выравнивание по левому краю пробелов в начале строки быть не должно
-	при выравнивание по правому краю пробелов в конце строки быть не должно
-	при выравнивание по ширине не должно быть пробелов в начале и конце строки.
-	знак препинания после слова не должен переносится
-	при форматировании по ширине ширина пробелов между словами в пределах одной строки не должна отличаться больше чем на 1
-	исходный текст отформатирован корректно, то есть не лишних пробелов между словами и перед знаками препинания

Опционально, чтобы получить 5 баллов (+1), необходимо выполнить хотя одно из следующих дополнений:
-	Реализовать все виды выравнивания
-	Добавить unit-тесты для полученного кода.

## Задание 2.
Реализовать простой калькулятор алгебраических выражений (например, на основе алгоритма обратной польской записи) переданных в виде строки

-	Выражение может содержать любое количество скобок - (, )
-	Необходимо поддержать бинарные операции +, -, *, /, ^
-	Унарный минус, унарный плюс
-	Между знаками операций и операндов может быть любое количество пробелов

В случае если передана некорректное выражение, которое невозможно распарсить, должно быть выброшено исключение.

Опционально, чтобы получить 5 баллов (+1), необходимо выполнить хотя одно из следующих дополнений:
-	добавить поддержку функций sin, cos, tg, ctg, lg, ln
-	добавить поддержку констант pi, e
-	добавить unit-тесты для полученного кода.

Примеры корректных выражений:
-	12+ 3
-	-3+4^+4
-	(4+3)*9/ -4
-	((-4+3))*8/4

Примеры некорректных выражений:
-	(-3+9))*30
-	+4 */ 33
-	*3 + 3
-	3+alksdjfklsdjfkldj+asdfd+3

В этом задание нельзя использовать сторонние библиотеки для парсинга выражения и для вычисления значений выражений

## Задание 3.
Реализовать набор классов, описывающий иерархию геометрических фигур (круг, квадрат, прямоугольник, треугольник). Для каждой фигуры должен быть реализован интерфейс с методами для вычисления периметра и площади фигуры.

Реализовать класс ShapeFactory с методами для создание фигур всех типов по переданным параметрам,  а также с методами, позволяющими создавать фигуру каждого типа со случайными размерами и метод, позволяющий создавать случайную фигуру.

Все создаваемые фигуры должны быть корректными (например, квадрат со стороной отрицательного размера - не является корректным)

Для демонстрации работы полученного кода в main создать список фигур, добавить в него по несколько фигур каждого типа. Вывести в консоль:
-	Суммарную площадь всех фигур
-	Суммарный периметр всех фигур
-	Фигуру с наибольшей/наименьшей площадью
-	Фигуру с наибольшим/наименьшим периметром

Опционально, чтобы получить 5 баллов (+1), необходимо добавить unit-тесты на код для создания фигур и вычисления площадей/периметром

## Задание 4.
Необходимо реализовать класс для работы с двумерными матрицами (можно выбрать любой числовой тип данных для элементов матрицы)

Класс должен предоставлять возможности для:
-	инициализации матрицы
-	просмотра значения элемента в позиции (i,j) и изменения этого элемента через оператор [ ]
-	просмотра размерностей матрицы
-	выполнения арифметических действий над матрицами через операторы +, -, *, +=, -+, *=. 	Уточнение: оператор “+” должен создавать новую матрицу и не меняет состояние матриц слева и справа от оператора. Оператор “+=” должен модифицировать матрицу слева (см. подсказку). Аналогично для других пар операторов.
-	умножения/деления матрицы на скаляр через операторы *, /, *=, /= 
-	использования операторов унарного минуса и плюса
-	сравнения двух матриц ==
-	Вывод состояния матрицы в строку - toString()

В случае, если какая-то операция не может быть выполнена должен быть выброшен соответствующий Exception.
Продемонстрировать работы всех методов в main

Опционально, чтобы получить 5 баллов (+1), необходимо выполнить хотя одно из следующих дополнений:
-	Разделить реализацию на иерархию из неизменяемой и изменяемой матрицы (Matrix, MutableMatrix)
-	Добавить unit-тесты

Документация:
https://kotlinlang.org/docs/operator-overloading.html

## Задание 5. 
Реализовать модель сервиса “Библиотека”.

В библиотеки есть книги, у каждой книги есть название, список авторов, жанр и год издания.
У библиотеки есть пользователи, у каждого из них есть имя и фамилия.

У каждой книги в библиотеки возможен один из статусов: 
-	доступна, 
-	используется юзером %user_name%, 
-	ожидается поступление, 
-	на рестоврации 

Реализовать сервис с возможностями:
-	Регистрировать новых пользователей и удалить существующих.
-	Добавлять новые книги
-	Просматривать список всех книг
-	Просматривать список всех доступных книг
-	Просматривать текущий статус всех книг
-	Осуществлять поиск книг по автору, названию, жанру году издания
-	Выдавать книгу пользователю
-	Возвращать книгу в библиотеку
-	Отправлять книгу на реставрацию
-	Добавлять информацию о том, что какая-то книга скоро будет доступна в библиотеке.

Ограничения: 
-	Для простоты считаем, что каждая книга существует в единственном экземпляре
-	Нельзя выдавать одному пользователю больше трех книг на руки
-	Все операции должны проверять возможность своего выполнения и проверять целостность данных  (например, нельзя выдавать книгу незарегистрированному пользователю или выдать книгу, которой нет в наличии)


Технические ограничения:
-	Все классы с данными (Author, Book, User, Status) должны быть неизменяемые

Опционально, чтобы получить 5 баллов (+1), необходимо выполнить хотя одно из следующих дополнений:
-	Реализовать все функции findBooks в виде одной функции с параметрами по умолчанию
-	Добавить unit-тесты
-	Добавить логирование операций сервиса

## Задание 6.
Используя код из работы №3 реализуйте класс ShapeCollector для хранения фигур с использованием обобщений (Generics). В качестве ограничения(upper bound) для параметра типа используете интерфейс Shape.
Класс должен предоставлять следующие методы:
-	add - добавляет фигуру в коллектор
-	addAll - добавляет коллекцию фигур в коллектор
-	getAll - возвращает список всех фигур, которые храняться в коллекторе
-	getAllSorted - возвращает все фигуры, которые хранятся в коллекторе, отсортированными с использованием переданного в метод компаратора (Comparator)
-	Реализуйте компараторы для сортировки списка фигур по площади и по периметру в порядке возрастания и в порядке убывания. Реализованные компараторы вынесите в отдельный объект ShapeComparators.
-	Реализуйте компараторы для сортировки окружностей по радиусу в порядке возрастания и убывания и вынесите их в ShapeComparators. 

В функции main должна быть созданы ShapeCollector’ы для Shape и Circle и продемонстрирована работа всех компараторов
Опционально, чтобы получить 5 баллов (+1), необходимо выполнить хотя одно из следующих дополнений:
-	Реализовать метод getAllByClass, который должен возвращать только фигуры класса, который передан в это метод в качестве параметра. Пример использования такого метода:
val squares = shapes.getAllByClass(Square::class.java)
-	Добавить unit-тесты

## Задание 7.
Используя код из работы №3 реализуйте
-	Возможность сериализации/десериализации иерархии фигур в формат JSON с использованием библиотеки kotlin-serialization-json. Вся логика сериализации должна быть вынесена в отдельный класс или объект.
-	Реализуйте запись полученной строки в формате JSON в файл, а также чтение такой строки из файла. Логика работы с файлами должна быть вынесена в отдельный класс или объект. API должно поддерживать возможность задать путь к входному и выходному файлу.

В качестве демонстрации работы кода в main 
-	Прочитайте из входного файла список фигур и десериализуйте его
-	Добавьте в этот список несколько случайных фигур
-	Сериализуйте полученный список и запишите в выходной файл (или в тот же, который был входным)

Опционально, чтобы получить 5 баллов (+1), необходимо выполнить хотя одно из следующих дополнений:
-	Добавить unit-тесты на сериализацию/десериализацию (не на работу с файлами)
